+ 원시 타입의 값 : 변경 불가능한 값 ↔ 객체(참조) 타입의 값 : 변경 가능한 값 <br/>
+ 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에 `실제 값` 저장 → 할당시 원본의 원시 값이 복사되어 전달(`값에 의한 전달`)
+ 객체를 변수에 할당하면 변수(확보된 메모리 공간)에 `참조 값` 저장 → 할당시 원본의 참조 값이 복사되어 전달(`참조에 의한 전달`)
<br/><br/>
# 11.1 원시 값
## 11.1.1 변경 불가능한 값
+ 변경 불가능하다는 `변수가 아닌 값에 대한 진술`이다 (원시 값 자체 변경❌ 변수 값은 재할당 통해 변경 가능⭕) <br/>
+ 상수 : 재할당 금지된 변수 (변수 값 변경 불가❌)
```js
const o = {};

// const 키워드 사용해 선언한 변수에 할당한 원시 값(상수)은 변경할 수 없지만 객체는 변경할 수 있다 
o.a = 1; 
console.log(o); // { a: 1 }
```
+ 원시 값은 어떤 일이 있어도 불변하므로 데이터의 신뢰성을 보장한다
+ 
<img src ="https://velog.velcdn.com/images%2Fmr_chu%2Fpost%2F6eec5b62-8105-483e-bfff-088b9318c8dd%2F%EB%B3%80%EC%88%98%20%EC%9E%AC%ED%95%A0%EB%8B%B9.jpeg"/>
> 값의 불변성 : 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.
## 문자열과 불변성
> 문자열은 원시타입으로 변경 불가
```
🗒️유사 배열 객체
배열처럼 인덱스로 프로퍼티 값 접근 가능, length 프로퍼티를 갖는 객체
-> 문자열도 유사 배열 객체!
```
```js
var str = 'string';

console.log(str[0]); // S
console.log(str.length); // 5
console.log(str.toUpperCase()); // STRING
```
```js
var str1 = 'apple';

str1[0] = 'A'; // 문자열은 원시값이므로 변경할 수 없음

console.log(str1); // apple   
```
## 값에 의한 전달
> 변수에 원시 값을 갖는 변수를 할당하면 할당받은 변수에는 할당되는 변수의 원시 값이 복사되어 전달되는 것
```js
var score = 80;
var copy = score;

score = 100;

console.log(score); // 100 (원본 값)
console.log(copy); // 80 (복사한 값)
```
```
💡값에 의한 전달은 값이 아닌 메모리 주소를 전달하는 것!
- 변수에는 값이 전달되는 것이 아니라 "메모리 주소가 전달"되기 때문
- 같은 말로, 변수와 같은 "식별자"는 값이 아닌 "메모리 주소를 기억"하고 있다.
```
> 한 변수에 원시 값을 갖는 변수를 할당하면, 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되며, 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 x
<br/><br/>
# 객체
## 변경 가능한 값
> 객체는 변경 가능한 값
+ 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값이 아닌 참조 값에 접근
  (참조 값 : 생성된 객체가 저장된 메모리 공간의 주소 그 자체)
+ 객체를 할당한 변수는 재할당 없이 객체를 직접 변경 가능
+ 즉, 재할당 없이 프로퍼티를 동적으로 추가 / 프로퍼티 값을 갱신 / 프로퍼티 자체 삭제 가능
```js
var person = {
    name : "yuri"
};

person.name = "Kim"; // 프로퍼티 값 갱신
person.address = "Seoul"; // 프로퍼티 값 동적 추가

console.log(person); // { name: 'Kim', address: 'Seoul' }
```
+ 자바스크립트 객체가 변경 가능한 값이여야 하는 이유? 메모리의 효율적 소비가 어렵고 성능이 나빠지는 것을 최소화하기 위해
+ 단점 : 여러개의 "식별자"가 하나의 객체를 "공유"할 수 있음
<br/><br/>
## 참조에 의한 전달
> 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되는 것
```js
var person = {
    name : 'Yuri'
};

var copy = person; // 참조 값을 복사 (얇은 복사) - copy와 person은 동일한 참조 값 가짐

console.log(copy === person); // true

copy.name = 'Kim';
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킴 
// 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고받음
console.log(person); // { name: 'Kim', address: 'Seoul' }
console.log(copy); // { name: 'Kim', address: 'Seoul' }
```
```js
var person1 = {
    name : 'Lee'
};

var person2 = {
    name : 'Lee'
};

console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```
## 얇은 복사 & 깊은 복사
> 얇은 복사 : 객체를 프로퍼티 값으로 갖는 객체의 경우 한 단계까지만 복사하는 것 / 객체에 중첩된 객체는 참조 값을 복사<br/>
> 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사하는 것 / 객체의 중첩된 객체까지 원시 값처럼 완전히 복사











